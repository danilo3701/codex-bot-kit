# BOT REVIEW INSTRUCTION · PR-Check v1.2 (Telegram-bots, SlotFlow style)

## Цель
Проверить фикс/фичу/рефактор так, чтобы:
- не было “общей рефлексии”
- проверка была гибкая (под тип задачи)
- модель не выдумывала и не “догадывалась” про код
- на выходе было: проблемы → минимальные правки (где искать) → тест-чеклист

---

## Главное правило (анти-галлюцинации)
Если в присланных фрагментах нет информации, модель обязана писать:
- `НЕ ВИЖУ В ФАЙЛАХ: ...`
- и попросить минимум: 1–2 файла или 40–120 строк вокруг нужного места

Запрещено:
- придумывать названия функций/переменных/констант
- писать “скорее всего у вас есть …” без подтверждения в коде

---

## Правило уверенности (чтобы не “лезть отвечать”)
Для каждого важного вывода (причина/место/правка) модель обязана дать:
- `Уверенность: 0–100%`

Правило применения:
- если уверенность >= 80% → можно давать конкретный вывод/план
- если уверенность < 80% → НЕ выдавать правку как факт
  вместо этого: `НУЖНО ДОСЛАТЬ: ...` (минимум, что нужно, чтобы поднять уверенность)

---

## Входные данные (что я присылаю в чат)
### 1) Контекст задачи (кратко, но достаточно)
- Тип: BUG / FEATURE / REFACTOR
- Приоритет: High / Medium / Low
- Где проявляется: экран/кнопка/сценарий
- Шаги воспроизведения (3–6 шагов)
- Факт: что сейчас происходит
- Ожидание: что должно происходить
- Ограничения: что нельзя менять (особенно UX)
- Лог/stacktrace (если есть)

### 2) Код (минимум)
Дай ровно то, что связано с проблемой:
- входной хендлер(ы) (callback/message)
- генератор клавиатуры (inline/reply), если есть кнопки
- рендер экрана (edit / текст), если есть UI
- чтение/сохранение данных (storage/db/json), если есть
- states и callback constants, если участвуют

---

## Формат ответа (что должен выдать LLM)
Ответ всегда состоит из 4 частей:

1) FLOWCHECK (вход → действия → выход)
2) 4 ЛИНЗЫ (гибко, но по порядку)
3) СИНТЕЗ: минимальный план правок + где искать
4) ТЕСТ-ЧЕКЛИСТ (10–20 пунктов, с краями + регрессией)

Никаких “общих советов”. Только конкретные проверки и выводы.

---

# Шаг 0 — Быстро понять тип проблемы (1–2 строки)
Модель обязана в начале написать:
- `Похоже на: (зависание callback / падение NameError / логическая дыра state / конфликт хендлеров / формат ввода / UI грязь / storage / рефактор риск)`
- `Что проверить в первую очередь: ...`
- `Уверенность: ...%`

---

# Шаг 1 — FLOWCHECK (обязателен всегда)
Цель: пройти путь как пользователь, от входа до выхода.

## 1.1 ВХОД (как мы попадаем в хендлер)
Проверить:
- какой именно триггер (callback prefix / текст / команда)
- какой state (или отсутствие state)
- нет ли более общего хендлера, который перехватывает событие
- нет ли дублей по prefix/state (см. DupCheck ниже)

Если это callback:
- должен быть `answer()` всегда (иначе “вечная загрузка”)

## 1.2 ДЕЙСТВИЯ (что делаем внутри)
Проверить:
- откуда берём данные (FSM/storage/json)
- какие данные могут быть пустыми или в неверном формате
- есть ли явная обработка ошибок (не молча)
- что именно меняется: данные, UI, state

## 1.3 ВЫХОД (что остаётся после выполнения)
Проверить:
- есть ли `return` где нужно (чтобы не “провалиться” дальше)
- ставится ли следующий state (если сценарий пошаговый)
- очищаются ли временные ключи (pending_input, flags и т.п.)
- UI: экран обновлён корректно (edit/клавиатура/сообщения)

---

# Шаг 2 — Гибкая самопроверка “ядро + модули”
## ЯДРО (всегда включено)
- Flowcheck (Шаг 1)
- Линза 1 (логика)
- Линза 2 (данные/state)
- Линза 3 (надёжность)
- Линза 4 (альтернативные пути)

## МОДУЛИ (включать по ситуации)
Модель обязана сама выбрать модули и написать строку:
`Включаю модули: DupCheck / CleanChat / NoHang / FormatGate / NeighborImpact / StorageIO / RefactorCheck`

Коротко когда включать:
- DupCheck: “иногда работает/иногда нет”, странные переходы, не тот экран
- CleanChat: экраны/настройки/ввод/кнопки, “культура чистого чата”
- NoHang: любые callbacks, долгие операции
- FormatGate: время/числа/%/валюта/id
- NeighborImpact: меняем ключи данных, state, клавиатуры, константы
- StorageIO: запись/чтение файлов/volume/db, “не сохранилось/сбросилось”
- PlanJudge: оценка по плану (без любви к длине и “красивой структуре”)
- RefactorCheck: Тип = REFACTOR или код разросся, много дублей, трудно читать, готовим базу под новые фичи

---

# PR-Check: 4 линзы (всегда по порядку)

## ЛИНЗА 1 — Логика (Logic)
Цель: нет ли противоречий и тупиков.

Проверки:
- есть ли “тупик” без Назад/Меню
- каждое действие имеет результат: сохранить/обновить/ошибка
- нет ли “двойного поведения” (и edit, и send без причины)
- переходы state понятны: вход → обработка → выход
- нет ли скрытых условий (“нужен teacher_id”, но не проверен)
- нет ли “молчаливых” выходов без сообщения/alert

Выход линзы:
- список логических проблем
- точные места: файл → хендлер/функция
- уверенность по каждой проблеме

---

## ЛИНЗА 2 — Данные и состояния (Data & State)
Цель: нет ли дыр в ключах, сохранении, очистке.

Проверки:
- все поля, которые показываются в UI, реально существуют
- временные ключи очищаются (pending_input/flags/redo_stack и т.п.)
- при ошибке данные не остаются “наполовину сохранёнными”
- UI и storage не расходятся (показываем одно, хранится другое)
- сортировка/нормализация делается до рендера

Выход линзы:
- список “может быть None/пусто”, “не очищается”, “не сохраняется”
- где именно это читать/писать (функции/места)
- уверенность по каждому пункту

---

## ЛИНЗА 3 — Надёжность (Reliability)
Цель: падения, зависания, типовые ошибки.

Проверки:
- для callback всегда есть `answer()`
- нет `await` на None / на не-async
- удаления сообщений безопасные (не ломают сценарий)
- при ошибке пользователь получает понятный результат (alert, если так принято)
- callback_data совпадает с обработчиком (prefix/параметры)
- нет мест, где код может упасть: NameError/KeyError/TypeError

Выход линзы:
- список “точек падения/зависания”
- где исправлять (хендлер/утилита)
- уверенность по каждому пункту

---

## ЛИНЗА 4 — Альтернативные пути (Alternatives)
Цель: что пользователь сделает “не по инструкции”.

Проверки:
- двойной клик по кнопке
- неверный ввод: пусто/пробелы/странный формат
- ушёл в меню посреди ввода и вернулся
- нажал кнопки “не в порядке”
- параллельные ветки (student/teacher), если у вас так бывает

Выход линзы:
- список сценариев + где сломается
- что добавить: guard/alert/clamp/return/set_state
- уверенность по каждому сценарию

---

# МОДУЛИ (добавочные проверки)

## DupCheck — дубли и конфликты (очень важно)
Проверить:
- нет ли двух callback-хендлеров на один prefix
- нет ли двух message-хендлеров на один state/фильтр
- общий фильтр не перекрывает частный
- константы callback_data не пересекаются

Выход:
- список дублей/конфликтов + где (декораторы/префиксы)
- уверенность по каждому дублю

---

## CleanChat — “культура чистого чата”
Проверить:
- главный экран: одно сообщение (edit_message_text / edit_markup)
- ввод пользователя удаляется после обработки
- ошибки: через Telegram alert (если так принято)
- старые inline-кнопки не остаются “мертвыми” (убрать/обновить)

Выход:
- где нарушена чистота и как исправить (точки: edit/delete/alert)
- уверенность по каждому пункту

---

## NoHang — защита от “вечной загрузки”
Проверить:
- callback.answer() везде и быстро
- нет долгих операций без ответа/без UI результата

Выход:
- где добавить answer/перестроить порядок действий
- уверенность

---

## FormatGate — строгие форматы (время/числа/%/валюта)
Проверить:
- валидируем и нормализуем формат
- при ошибке: понятная подсказка формата
- ничего не “додумываем” (если нет данных — ошибка/запрос уточнения)

Выход:
- что валидировать и где (парсер/хендлер)
- уверенность

---

## StorageIO — чтение/запись (файлы/volume/db)
Проверить:
- где именно читаем и где пишем (функции/пути/ключи)
- что запись реально вызывается (не забыли `await` / не забыли save)
- что ошибки записи ловим и показываем понятный результат
- что данные не перетираются пустыми значениями
- если это файл: запись “атомарно” (не ломаем файл при сбое)
- если это volume/railway: путь и права корректные

Выход:
- список точек чтения/записи + где риск “не сохранилось”
- что проверить в первую очередь
- уверенность

---

## PlanJudge — оценка по плану (без bias к длине)
Смысл:
- модели часто “любят” длинные и детальные ответы и ставят им выше оценку, даже если суть хуже
- PlanJudge заставляет сначала составить план оценки: что главное, что вторично
- дальше оценка идёт строго по этому плану, а не по “красоте и объёму”

Когда включать:
- когда делаешь PR-Check и видишь риск “слишком много текста, мало сути”
- когда решение выглядит “оформлено идеально”, но есть сомнения в корректности
- когда сравниваешь 2 варианта фикса/плана и боишься выбрать “самый длинный”

План оценки (2 уровня, кратко):
A) Первичные критерии (без них решение = провал)
1) Не падает и не зависает (callback answer, нет исключений)
2) Правильная логика и вход→выход (state/return/cleanup)
3) Данные и сохранение консистентны (UI не врёт storage)

B) Вторичные критерии (желательно, но не ценой первичных)
1) Чистый чат (edit + удаление ввода + alert)
2) Минимальность правок (не трогать соседние ветки)
3) Читаемость и аккуратность структуры (но без “размазать на 20 функций”)

Формат выхода по PlanJudge (обязателен, коротко):
1) `План оценки` (A первичные, B вторичные)
2) `Оценка по плану` = пройтись по пунктам A, потом B
3) `Вердикт`:
   - PASS = первичные выполнены
   - FAIL = хотя бы один первичный не выполнен
4) `Что нужно дослать` (если не хватает данных) + уверенность


## RefactorCheck — Structured Refactoring (рефактор по чек-листу техник)
Смысл:
- не “сделай код лучше”
- а “пройди по списку техник и примени только там, где это реально нужно”
- и обязательно отчитайся, что именно применил (чтобы не было “я сделал”, но не сделал)

Проверить (простые техники, которые обычно полезны):
1) Remove Dead Code = удалить то, что не используется
2) Rename Variable = дать понятные имена
3) Replace Magic Number = числа заменить на константы
4) Introduce Explaining Variable = сложное выражение вынести в переменную с именем
5) Extract Method = вынести повтор (только если повтор реально есть или блок большой)

Ограничения читаемости (важно):
- не дробить на много микрофункций по 3–4 строки, если они вызываются 1 раз
- не менять стиль проекта и имена состояний/ключей без нужды
- не менять поведение (только структура), иначе это уже BUG/FIX, а не рефактор

Формат выхода по RefactorCheck (обязателен):
A) `План рефактора (5–10 пунктов)` = что сделать и где искать (файл → функция)
B) `Список техник и сколько раз` (пример):
   - Rename Variable (3)
   - Replace Magic Number (2)
   - Remove Dead Code (1)
C) `Риск (что может сломаться)` + `как тестить` (2–6 пунктов)
D) Уверенность по плану

---

## NeighborImpact — не ломаем соседние ветки
Проверить:
- если меняем ключи данных/state/клавиатуры: кто ещё это использует
- регрессия: какие экраны/ветки проверить после

Выход:
- список “что может сломаться” + где тестить
- уверенность

---

# Шаг 3 — Синтез (обязателен)
После всех проверок модель обязана дать:

1) Список проблем по важности (High/Med/Low) + уверенность
2) Минимальный безопасный план (3–10 пунктов)
3) Где искать: файл → хендлер/функция → что именно проверить
4) Если не хватает данных:
   - `НУЖНО ДОСЛАТЬ: ...` (минимум)
   - и для каждого пункта “зачем это нужно”

---

# Шаг 4 — Тест-чеклист (10–20 пунктов)
Должны быть:
- базовый сценарий (как в шагах воспроизведения)
- краевые случаи (пусто/невалидно/двойной клик/назад/отмена)
- регрессия (соседние ветки)
- проверка чистоты чата (edit/удаления/alert)
- проверка “не висит” (answer)
- если был refactor: 3–5 типичных сценариев + 3–5 крайних

---

## Режимы применения
### Режим A: Быстрый аудит (по умолчанию)
- Шаг 0 → Flowcheck → 4 линзы → синтез → тест-чеклист
- Модули подключать только если уместно

### Режим B: Глубокий аудит
- всё из режима A
- + для каждой проблемы: риск (High/Med/Low) и “что сломаем, если сделать неправильно”
- + NeighborImpact почти всегда включён

---

Сделай PR-Check v1.2:
Шаг 0 + Flowcheck + 4 линзы + (по ситуации модули) + синтез + тест-чеклист.
